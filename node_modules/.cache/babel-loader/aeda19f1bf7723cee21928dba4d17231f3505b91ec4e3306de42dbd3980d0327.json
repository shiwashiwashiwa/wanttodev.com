{"ast":null,"code":"/**\n * 画像の存在を確認する関数\n */\nconst checkImageExists = src => {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.onload = () => resolve(true);\n    img.onerror = () => resolve(false);\n    img.src = src;\n  });\n};\n\n/**\n * 動画ファイルの存在を確認する関数\n */\nconst checkVideoExists = src => {\n  return fetch(src, {\n    method: \"HEAD\"\n  }).then(response => {\n    // 200-299のステータスコードは成功\n    return response.ok;\n  }).catch(() => {\n    // エラーが発生した場合は存在しないとみなす\n    return false;\n  });\n};\n\n/**\n * 指定された作品IDの動画ファイルを検出する関数\n * video01.mp4, video02.mp4, video03.mp4などの番号付き動画ファイルを検出\n * 最適化: 連続する失敗が一定数続いたら検索を停止\n */\nexport async function detectVideoFiles(workId) {\n  const videos = [];\n  const maxVideoNumber = 20; // 最大20個まで検索（100から削減）\n  const maxConsecutiveFailures = 3; // 連続失敗の上限\n\n  // video01.mp4, video02.mp4などの番号付き動画ファイルを検索\n  // バッチ処理で並列数を制限（一度に5個ずつ）\n  const batchSize = 5;\n  let consecutiveFailures = 0;\n  for (let batchStart = 1; batchStart <= maxVideoNumber; batchStart += batchSize) {\n    const batchEnd = Math.min(batchStart + batchSize - 1, maxVideoNumber);\n    const checkPromises = [];\n    for (let i = batchStart; i <= batchEnd; i++) {\n      const videoNumber = i.toString().padStart(2, \"0\");\n      const videoPath = `/images/works/${workId}/video${videoNumber}.mp4`;\n      checkPromises.push(checkVideoExists(videoPath).then(exists => ({\n        number: i,\n        exists\n      })));\n    }\n    const results = await Promise.all(checkPromises);\n\n    // バッチ内で存在する動画ファイルを処理\n    let batchHasVideo = false;\n    results.filter(result => result.exists).sort((a, b) => a.number - b.number).forEach(result => {\n      const videoNumber = result.number.toString().padStart(2, \"0\");\n      videos.push({\n        type: \"video\",\n        src: `/images/works/${workId}/video${videoNumber}.mp4`,\n        alt: `作品${workId}の動画${videoNumber}`\n      });\n      batchHasVideo = true;\n      consecutiveFailures = 0; // 成功したらリセット\n    });\n\n    // バッチ内に動画がなかった場合\n    if (!batchHasVideo) {\n      consecutiveFailures += batchSize;\n      // 連続失敗が上限に達したら検索を停止\n      if (consecutiveFailures >= maxConsecutiveFailures * batchSize) {\n        break;\n      }\n    }\n  }\n  return videos;\n}\n\n/**\n * public/images/works内の連番フォルダを検出する関数\n * サムネイル画像の存在を確認して、有効なフォルダを判定\n */\nexport async function detectWorksFolders(maxId = 100) {\n  const detectedFolders = [];\n  const checkPromises = [];\n\n  // 1からmaxIdまで順番にチェック\n  for (let id = 1; id <= maxId; id++) {\n    // thumbnail.webpとthumbnail.pngの両方をチェック\n    const thumbnailWebpPath = `/images/works/${id}/thumbnail.webp`;\n    const thumbnailPngPath = `/images/works/${id}/thumbnail.png`;\n    checkPromises.push(Promise.all([checkImageExists(thumbnailWebpPath), checkImageExists(thumbnailPngPath)]).then(([existsWebp, existsPng]) => {\n      if (existsWebp || existsPng) {\n        detectedFolders.push(id);\n      }\n      return existsWebp || existsPng;\n    }));\n  }\n\n  // 並列で画像の存在を確認\n  await Promise.all(checkPromises);\n\n  // 数値順にソート\n  return detectedFolders.sort((a, b) => a - b);\n}\n\n/**\n * デフォルトのworksデータを生成する関数\n */\nexport function generateDefaultWorkData(id) {\n  const currentDate = new Date();\n  const year = currentDate.getFullYear();\n  const month = String(currentDate.getMonth() + 1).padStart(2, \"0\");\n  const dateString = `${year}.${month}`;\n  return {\n    id,\n    title: `作品 ${id}`,\n    date: dateString,\n    role: \"開発・デザイン\",\n    client: \"クライアント名\",\n    industry: \"その他\",\n    technologies: [\"HTML\", \"CSS\", \"JavaScript\"],\n    category: [\"サービスサイト\"],\n    details: {\n      overview: [\"作品の概要をここに記入してください。\"],\n      challenge: [\"課題をここに記入してください。\"],\n      solution: [\"解決策をここに記入してください。\"],\n      result: [\"成果をここに記入してください。\"],\n      features: [\"主な機能をここに記入してください。\"],\n      link: \"\"\n    },\n    mediaData: {\n      images: [],\n      videos: []\n    },\n    isVisible: true,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n}\n\n/**\n * 既存のworksデータと自動生成データをマージする関数\n * 既存データを優先し、存在しないIDのみ自動生成データを追加\n */\nexport function mergeWorksData(existingWorks, autoGeneratedWorks) {\n  const existingIds = new Set(existingWorks.map(work => work.id));\n  const newWorks = autoGeneratedWorks.filter(work => !existingIds.has(work.id));\n\n  // 既存データと新規データをマージ（既存データを優先）\n  return [...existingWorks, ...newWorks].sort((a, b) => a.id - b.id);\n}\n\n/**\n * 既存のworksデータの動画ファイルを自動検出・更新する関数\n */\nexport async function updateVideoFilesInWorks(works) {\n  console.log(\"🎬 動画ファイルを自動検出中...\");\n  const updatedWorks = await Promise.all(works.map(async work => {\n    const detectedVideos = await detectVideoFiles(work.id);\n    if (detectedVideos.length > 0) {\n      console.log(`✅ 作品${work.id}: ${detectedVideos.length}個の動画ファイルを検出しました`);\n    } else {\n      console.log(`ℹ️ 作品${work.id}: 動画ファイルが見つかりませんでした`);\n    }\n\n    // 動画が検出されなかった場合も空の配列を設定して、既存の動画データをクリア\n    return {\n      ...work,\n      mediaData: {\n        ...work.mediaData,\n        videos: detectedVideos\n      }\n    };\n  }));\n  return updatedWorks;\n}\n\n/**\n * フォルダから自動的にworksデータを生成する関数\n */\nexport async function autoGenerateWorksData(existingWorks) {\n  console.log(\"🔍 worksフォルダを自動検出中...\");\n\n  // フォルダを検出\n  const detectedFolders = await detectWorksFolders(20);\n  console.log(`✅ ${detectedFolders.length}個のworksフォルダを検出しました:`, detectedFolders);\n  if (detectedFolders.length === 0) {\n    console.log(\"⚠️ worksフォルダが見つかりませんでした\");\n    // フォルダが見つからなくても、既存データの動画ファイルを更新\n    return await updateVideoFilesInWorks(existingWorks);\n  }\n\n  // 既存のIDを取得\n  const existingIds = new Set(existingWorks.map(work => work.id));\n\n  // 検出されたフォルダから、既存データにないIDのworksデータを生成\n  const newWorks = [];\n  for (const id of detectedFolders) {\n    if (!existingIds.has(id)) {\n      const defaultWork = generateDefaultWorkData(id);\n      newWorks.push(defaultWork);\n      console.log(`📝 新規worksデータを生成しました: ID ${id}`);\n    }\n  }\n\n  // 既存データとマージ\n  let mergedWorks = mergeWorksData(existingWorks, newWorks);\n\n  // すべてのworksデータの動画ファイルを自動検出・更新\n  mergedWorks = await updateVideoFilesInWorks(mergedWorks);\n  console.log(`✅ worksデータをマージしました: 合計 ${mergedWorks.length}件`);\n  return mergedWorks;\n}","map":{"version":3,"names":["checkImageExists","src","Promise","resolve","img","Image","onload","onerror","checkVideoExists","fetch","method","then","response","ok","catch","detectVideoFiles","workId","videos","maxVideoNumber","maxConsecutiveFailures","batchSize","consecutiveFailures","batchStart","batchEnd","Math","min","checkPromises","i","videoNumber","toString","padStart","videoPath","push","exists","number","results","all","batchHasVideo","filter","result","sort","a","b","forEach","type","alt","detectWorksFolders","maxId","detectedFolders","id","thumbnailWebpPath","thumbnailPngPath","existsWebp","existsPng","generateDefaultWorkData","currentDate","Date","year","getFullYear","month","String","getMonth","dateString","title","date","role","client","industry","technologies","category","details","overview","challenge","solution","features","link","mediaData","images","isVisible","createdAt","toISOString","updatedAt","mergeWorksData","existingWorks","autoGeneratedWorks","existingIds","Set","map","work","newWorks","has","updateVideoFilesInWorks","works","console","log","updatedWorks","detectedVideos","length","autoGenerateWorksData","defaultWork","mergedWorks"],"sources":["/Users/shiwa/Desktop/wanttodev.com/src/lib/worksAutoGenerator.ts"],"sourcesContent":["import { Works, WorkCategory, Technology, MediaItem } from \"../data/works\";\n\n/**\n * 画像の存在を確認する関数\n */\nconst checkImageExists = (src: string): Promise<boolean> => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => resolve(true);\n    img.onerror = () => resolve(false);\n    img.src = src;\n  });\n};\n\n/**\n * 動画ファイルの存在を確認する関数\n */\nconst checkVideoExists = (src: string): Promise<boolean> => {\n  return fetch(src, { method: \"HEAD\" })\n    .then((response) => {\n      // 200-299のステータスコードは成功\n      return response.ok;\n    })\n    .catch(() => {\n      // エラーが発生した場合は存在しないとみなす\n      return false;\n    });\n};\n\n/**\n * 指定された作品IDの動画ファイルを検出する関数\n * video01.mp4, video02.mp4, video03.mp4などの番号付き動画ファイルを検出\n * 最適化: 連続する失敗が一定数続いたら検索を停止\n */\nexport async function detectVideoFiles(workId: number): Promise<MediaItem[]> {\n  const videos: MediaItem[] = [];\n  const maxVideoNumber = 20; // 最大20個まで検索（100から削減）\n  const maxConsecutiveFailures = 3; // 連続失敗の上限\n\n  // video01.mp4, video02.mp4などの番号付き動画ファイルを検索\n  // バッチ処理で並列数を制限（一度に5個ずつ）\n  const batchSize = 5;\n  let consecutiveFailures = 0;\n\n  for (let batchStart = 1; batchStart <= maxVideoNumber; batchStart += batchSize) {\n    const batchEnd = Math.min(batchStart + batchSize - 1, maxVideoNumber);\n    const checkPromises: Promise<{ number: number; exists: boolean }>[] = [];\n\n    for (let i = batchStart; i <= batchEnd; i++) {\n      const videoNumber = i.toString().padStart(2, \"0\");\n      const videoPath = `/images/works/${workId}/video${videoNumber}.mp4`;\n      \n      checkPromises.push(\n        checkVideoExists(videoPath).then((exists) => ({\n          number: i,\n          exists,\n        }))\n      );\n    }\n\n    const results = await Promise.all(checkPromises);\n    \n    // バッチ内で存在する動画ファイルを処理\n    let batchHasVideo = false;\n    results\n      .filter((result) => result.exists)\n      .sort((a, b) => a.number - b.number)\n      .forEach((result) => {\n        const videoNumber = result.number.toString().padStart(2, \"0\");\n        videos.push({\n          type: \"video\",\n          src: `/images/works/${workId}/video${videoNumber}.mp4`,\n          alt: `作品${workId}の動画${videoNumber}`,\n        });\n        batchHasVideo = true;\n        consecutiveFailures = 0; // 成功したらリセット\n      });\n\n    // バッチ内に動画がなかった場合\n    if (!batchHasVideo) {\n      consecutiveFailures += batchSize;\n      // 連続失敗が上限に達したら検索を停止\n      if (consecutiveFailures >= maxConsecutiveFailures * batchSize) {\n        break;\n      }\n    }\n  }\n\n  return videos;\n}\n\n/**\n * public/images/works内の連番フォルダを検出する関数\n * サムネイル画像の存在を確認して、有効なフォルダを判定\n */\nexport async function detectWorksFolders(\n  maxId: number = 100\n): Promise<number[]> {\n  const detectedFolders: number[] = [];\n  const checkPromises: Promise<boolean>[] = [];\n\n  // 1からmaxIdまで順番にチェック\n  for (let id = 1; id <= maxId; id++) {\n    // thumbnail.webpとthumbnail.pngの両方をチェック\n    const thumbnailWebpPath = `/images/works/${id}/thumbnail.webp`;\n    const thumbnailPngPath = `/images/works/${id}/thumbnail.png`;\n    \n    checkPromises.push(\n      Promise.all([\n        checkImageExists(thumbnailWebpPath),\n        checkImageExists(thumbnailPngPath)\n      ]).then(([existsWebp, existsPng]) => {\n        if (existsWebp || existsPng) {\n          detectedFolders.push(id);\n        }\n        return existsWebp || existsPng;\n      })\n    );\n  }\n\n  // 並列で画像の存在を確認\n  await Promise.all(checkPromises);\n\n  // 数値順にソート\n  return detectedFolders.sort((a, b) => a - b);\n}\n\n/**\n * デフォルトのworksデータを生成する関数\n */\nexport function generateDefaultWorkData(id: number): Works {\n  const currentDate = new Date();\n  const year = currentDate.getFullYear();\n  const month = String(currentDate.getMonth() + 1).padStart(2, \"0\");\n  const dateString = `${year}.${month}`;\n\n  return {\n    id,\n    title: `作品 ${id}`,\n    date: dateString,\n    role: \"開発・デザイン\",\n    client: \"クライアント名\",\n    industry: \"その他\",\n    technologies: [\"HTML\", \"CSS\", \"JavaScript\"] as Technology[],\n    category: [\"サービスサイト\"] as WorkCategory[],\n    details: {\n      overview: [\"作品の概要をここに記入してください。\"],\n      challenge: [\"課題をここに記入してください。\"],\n      solution: [\"解決策をここに記入してください。\"],\n      result: [\"成果をここに記入してください。\"],\n      features: [\"主な機能をここに記入してください。\"],\n      link: \"\",\n    },\n    mediaData: {\n      images: [],\n      videos: [],\n    },\n    isVisible: true,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * 既存のworksデータと自動生成データをマージする関数\n * 既存データを優先し、存在しないIDのみ自動生成データを追加\n */\nexport function mergeWorksData(\n  existingWorks: Works[],\n  autoGeneratedWorks: Works[]\n): Works[] {\n  const existingIds = new Set(existingWorks.map((work) => work.id));\n  const newWorks = autoGeneratedWorks.filter(\n    (work) => !existingIds.has(work.id)\n  );\n\n  // 既存データと新規データをマージ（既存データを優先）\n  return [...existingWorks, ...newWorks].sort((a, b) => a.id - b.id);\n}\n\n/**\n * 既存のworksデータの動画ファイルを自動検出・更新する関数\n */\nexport async function updateVideoFilesInWorks(\n  works: Works[]\n): Promise<Works[]> {\n  console.log(\"🎬 動画ファイルを自動検出中...\");\n\n  const updatedWorks = await Promise.all(\n    works.map(async (work) => {\n      const detectedVideos = await detectVideoFiles(work.id);\n      \n      if (detectedVideos.length > 0) {\n        console.log(\n          `✅ 作品${work.id}: ${detectedVideos.length}個の動画ファイルを検出しました`\n        );\n      } else {\n        console.log(`ℹ️ 作品${work.id}: 動画ファイルが見つかりませんでした`);\n      }\n      \n      // 動画が検出されなかった場合も空の配列を設定して、既存の動画データをクリア\n      return {\n        ...work,\n        mediaData: {\n          ...work.mediaData,\n          videos: detectedVideos,\n        },\n      };\n    })\n  );\n\n  return updatedWorks;\n}\n\n/**\n * フォルダから自動的にworksデータを生成する関数\n */\nexport async function autoGenerateWorksData(\n  existingWorks: Works[]\n): Promise<Works[]> {\n  console.log(\"🔍 worksフォルダを自動検出中...\");\n\n  // フォルダを検出\n  const detectedFolders = await detectWorksFolders(20);\n  console.log(\n    `✅ ${detectedFolders.length}個のworksフォルダを検出しました:`,\n    detectedFolders\n  );\n\n  if (detectedFolders.length === 0) {\n    console.log(\"⚠️ worksフォルダが見つかりませんでした\");\n    // フォルダが見つからなくても、既存データの動画ファイルを更新\n    return await updateVideoFilesInWorks(existingWorks);\n  }\n\n  // 既存のIDを取得\n  const existingIds = new Set(existingWorks.map((work) => work.id));\n\n  // 検出されたフォルダから、既存データにないIDのworksデータを生成\n  const newWorks: Works[] = [];\n  for (const id of detectedFolders) {\n    if (!existingIds.has(id)) {\n      const defaultWork = generateDefaultWorkData(id);\n      newWorks.push(defaultWork);\n      console.log(`📝 新規worksデータを生成しました: ID ${id}`);\n    }\n  }\n\n  // 既存データとマージ\n  let mergedWorks = mergeWorksData(existingWorks, newWorks);\n\n  // すべてのworksデータの動画ファイルを自動検出・更新\n  mergedWorks = await updateVideoFilesInWorks(mergedWorks);\n\n  console.log(\n    `✅ worksデータをマージしました: 合計 ${mergedWorks.length}件`\n  );\n\n  return mergedWorks;\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}