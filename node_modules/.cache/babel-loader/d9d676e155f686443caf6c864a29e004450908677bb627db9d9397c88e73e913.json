{"ast":null,"code":"/**\n * 画像の存在を確認する関数\n */\nconst checkImageExists = src => {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.onload = () => resolve(true);\n    img.onerror = () => resolve(false);\n    img.src = src;\n  });\n};\n\n/**\n * 動画ファイルの存在を確認する関数\n */\nconst checkVideoExists = src => {\n  return fetch(src, {\n    method: \"HEAD\"\n  }).then(response => {\n    // 200-299のステータスコードは成功\n    return response.ok;\n  }).catch(() => {\n    // エラーが発生した場合は存在しないとみなす\n    return false;\n  });\n};\n\n/**\n * 指定された作品IDの動画ファイルを検出する関数\n * video01.mp4, video02.mp4, video03.mp4などの番号付き動画ファイルを検出\n * 最適化: 連続する失敗が一定数続いたら検索を停止\n */\nexport async function detectVideoFiles(workId) {\n  const videos = [];\n  const maxVideoNumber = 20; // 最大20個まで検索（100から削減）\n  const maxConsecutiveFailures = 3; // 連続失敗の上限\n\n  // video01.mp4, video02.mp4などの番号付き動画ファイルを検索\n  // バッチ処理で並列数を制限（一度に5個ずつ）\n  const batchSize = 5;\n  let consecutiveFailures = 0;\n  for (let batchStart = 1; batchStart <= maxVideoNumber; batchStart += batchSize) {\n    const batchEnd = Math.min(batchStart + batchSize - 1, maxVideoNumber);\n    const checkPromises = [];\n    for (let i = batchStart; i <= batchEnd; i++) {\n      const videoNumber = i.toString().padStart(2, \"0\");\n      const videoPath = `/images/works/${workId}/video${videoNumber}.mp4`;\n      checkPromises.push(checkVideoExists(videoPath).then(exists => ({\n        number: i,\n        exists\n      })));\n    }\n    const results = await Promise.all(checkPromises);\n\n    // バッチ内で存在する動画ファイルを処理\n    const existingVideos = results.filter(result => result.exists).sort((a, b) => a.number - b.number);\n    const batchHasVideo = existingVideos.length > 0;\n\n    // 動画が見つかった場合は追加\n    for (const result of existingVideos) {\n      const videoNumber = result.number.toString().padStart(2, \"0\");\n      videos.push({\n        type: \"video\",\n        src: `/images/works/${workId}/video${videoNumber}.mp4`,\n        alt: `作品${workId}の動画${videoNumber}`\n      });\n    }\n\n    // バッチ内に動画がなかった場合\n    if (!batchHasVideo) {\n      consecutiveFailures += batchSize;\n      // 連続失敗が上限に達したら検索を停止\n      if (consecutiveFailures >= maxConsecutiveFailures * batchSize) {\n        break;\n      }\n    } else {\n      // 成功したらリセット\n      consecutiveFailures = 0;\n    }\n  }\n  return videos;\n}\n\n/**\n * public/images/works内の連番フォルダを検出する関数\n * サムネイル画像の存在を確認して、有効なフォルダを判定\n * 最適化: バッチ処理で並列数を制限\n */\nexport async function detectWorksFolders(maxId = 20) {\n  const detectedFolders = [];\n  const batchSize = 5; // 一度に5個ずつチェック\n\n  // バッチ処理で並列数を制限\n  for (let batchStart = 1; batchStart <= maxId; batchStart += batchSize) {\n    const batchEnd = Math.min(batchStart + batchSize - 1, maxId);\n    const checkPromises = [];\n\n    // バッチ内のIDをチェック\n    for (let id = batchStart; id <= batchEnd; id++) {\n      // thumbnail.webpとthumbnail.pngの両方をチェック\n      const thumbnailWebpPath = `/images/works/${id}/thumbnail.webp`;\n      const thumbnailPngPath = `/images/works/${id}/thumbnail.png`;\n      checkPromises.push(Promise.all([checkImageExists(thumbnailWebpPath), checkImageExists(thumbnailPngPath)]).then(([existsWebp, existsPng]) => {\n        if (existsWebp || existsPng) {\n          detectedFolders.push(id);\n        }\n        return existsWebp || existsPng;\n      }));\n    }\n\n    // バッチごとに並列で画像の存在を確認\n    await Promise.all(checkPromises);\n  }\n\n  // 数値順にソート\n  return detectedFolders.sort((a, b) => a - b);\n}\n\n/**\n * デフォルトのworksデータを生成する関数\n */\nexport function generateDefaultWorkData(id) {\n  const currentDate = new Date();\n  const year = currentDate.getFullYear();\n  const month = String(currentDate.getMonth() + 1).padStart(2, \"0\");\n  const dateString = `${year}.${month}`;\n  return {\n    id,\n    title: `作品 ${id}`,\n    date: dateString,\n    role: \"開発・デザイン\",\n    client: \"クライアント名\",\n    industry: \"その他\",\n    technologies: [\"HTML\", \"CSS\", \"JavaScript\"],\n    category: [\"サービスサイト\"],\n    details: {\n      overview: [\"作品の概要をここに記入してください。\"],\n      challenge: [\"課題をここに記入してください。\"],\n      solution: [\"解決策をここに記入してください。\"],\n      result: [\"成果をここに記入してください。\"],\n      features: [\"主な機能をここに記入してください。\"],\n      link: \"\"\n    },\n    mediaData: {\n      images: [],\n      videos: []\n    },\n    isVisible: true,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n}\n\n/**\n * 既存のworksデータと自動生成データをマージする関数\n * 既存データを優先し、存在しないIDのみ自動生成データを追加\n */\nexport function mergeWorksData(existingWorks, autoGeneratedWorks) {\n  const existingIds = new Set(existingWorks.map(work => work.id));\n  const newWorks = autoGeneratedWorks.filter(work => !existingIds.has(work.id));\n\n  // 既存データと新規データをマージ（既存データを優先）\n  return [...existingWorks, ...newWorks].sort((a, b) => a.id - b.id);\n}\n\n/**\n * 既存のworksデータの動画ファイルを自動検出・更新する関数\n * 最適化: 既に動画データがある場合はスキップ\n */\nexport async function updateVideoFilesInWorks(works) {\n  console.log(\"🎬 動画ファイルを自動検出中...\");\n  const updatedWorks = await Promise.all(works.map(async work => {\n    // 既に動画データが存在し、かつ空でない場合はスキップ（パフォーマンス向上）\n    if (work.mediaData.videos && work.mediaData.videos.length > 0) {\n      console.log(`⏭️ 作品${work.id}: 既存の動画データがあるためスキップ`);\n      return work;\n    }\n    const detectedVideos = await detectVideoFiles(work.id);\n    if (detectedVideos.length > 0) {\n      console.log(`✅ 作品${work.id}: ${detectedVideos.length}個の動画ファイルを検出しました`);\n    } else {\n      console.log(`ℹ️ 作品${work.id}: 動画ファイルが見つかりませんでした`);\n    }\n\n    // 動画が検出されなかった場合も空の配列を設定して、既存の動画データをクリア\n    return {\n      ...work,\n      mediaData: {\n        ...work.mediaData,\n        videos: detectedVideos\n      }\n    };\n  }));\n  return updatedWorks;\n}\n\n/**\n * フォルダから自動的にworksデータを生成する関数\n */\nexport async function autoGenerateWorksData(existingWorks) {\n  console.log(\"🔍 worksフォルダを自動検出中...\");\n\n  // フォルダを検出\n  const detectedFolders = await detectWorksFolders(20);\n  console.log(`✅ ${detectedFolders.length}個のworksフォルダを検出しました:`, detectedFolders);\n  if (detectedFolders.length === 0) {\n    console.log(\"⚠️ worksフォルダが見つかりませんでした\");\n    // フォルダが見つからなくても、既存データの動画ファイルを更新\n    return await updateVideoFilesInWorks(existingWorks);\n  }\n\n  // 既存のIDを取得\n  const existingIds = new Set(existingWorks.map(work => work.id));\n\n  // 検出されたフォルダから、既存データにないIDのworksデータを生成\n  const newWorks = [];\n  for (const id of detectedFolders) {\n    if (!existingIds.has(id)) {\n      const defaultWork = generateDefaultWorkData(id);\n      newWorks.push(defaultWork);\n      console.log(`📝 新規worksデータを生成しました: ID ${id}`);\n    }\n  }\n\n  // 既存データとマージ\n  let mergedWorks = mergeWorksData(existingWorks, newWorks);\n\n  // すべてのworksデータの動画ファイルを自動検出・更新\n  mergedWorks = await updateVideoFilesInWorks(mergedWorks);\n  console.log(`✅ worksデータをマージしました: 合計 ${mergedWorks.length}件`);\n  return mergedWorks;\n}","map":{"version":3,"names":["checkImageExists","src","Promise","resolve","img","Image","onload","onerror","checkVideoExists","fetch","method","then","response","ok","catch","detectVideoFiles","workId","videos","maxVideoNumber","maxConsecutiveFailures","batchSize","consecutiveFailures","batchStart","batchEnd","Math","min","checkPromises","i","videoNumber","toString","padStart","videoPath","push","exists","number","results","all","existingVideos","filter","result","sort","a","b","batchHasVideo","length","type","alt","detectWorksFolders","maxId","detectedFolders","id","thumbnailWebpPath","thumbnailPngPath","existsWebp","existsPng","generateDefaultWorkData","currentDate","Date","year","getFullYear","month","String","getMonth","dateString","title","date","role","client","industry","technologies","category","details","overview","challenge","solution","features","link","mediaData","images","isVisible","createdAt","toISOString","updatedAt","mergeWorksData","existingWorks","autoGeneratedWorks","existingIds","Set","map","work","newWorks","has","updateVideoFilesInWorks","works","console","log","updatedWorks","detectedVideos","autoGenerateWorksData","defaultWork","mergedWorks"],"sources":["/Users/shiwa/Desktop/wanttodev.com/src/lib/worksAutoGenerator.ts"],"sourcesContent":["import { Works, WorkCategory, Technology, MediaItem } from \"../data/works\";\n\n/**\n * 画像の存在を確認する関数\n */\nconst checkImageExists = (src: string): Promise<boolean> => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => resolve(true);\n    img.onerror = () => resolve(false);\n    img.src = src;\n  });\n};\n\n/**\n * 動画ファイルの存在を確認する関数\n */\nconst checkVideoExists = (src: string): Promise<boolean> => {\n  return fetch(src, { method: \"HEAD\" })\n    .then((response) => {\n      // 200-299のステータスコードは成功\n      return response.ok;\n    })\n    .catch(() => {\n      // エラーが発生した場合は存在しないとみなす\n      return false;\n    });\n};\n\n/**\n * 指定された作品IDの動画ファイルを検出する関数\n * video01.mp4, video02.mp4, video03.mp4などの番号付き動画ファイルを検出\n * 最適化: 連続する失敗が一定数続いたら検索を停止\n */\nexport async function detectVideoFiles(workId: number): Promise<MediaItem[]> {\n  const videos: MediaItem[] = [];\n  const maxVideoNumber = 20; // 最大20個まで検索（100から削減）\n  const maxConsecutiveFailures = 3; // 連続失敗の上限\n\n  // video01.mp4, video02.mp4などの番号付き動画ファイルを検索\n  // バッチ処理で並列数を制限（一度に5個ずつ）\n  const batchSize = 5;\n  let consecutiveFailures = 0;\n\n  for (let batchStart = 1; batchStart <= maxVideoNumber; batchStart += batchSize) {\n    const batchEnd = Math.min(batchStart + batchSize - 1, maxVideoNumber);\n    const checkPromises: Promise<{ number: number; exists: boolean }>[] = [];\n\n    for (let i = batchStart; i <= batchEnd; i++) {\n      const videoNumber = i.toString().padStart(2, \"0\");\n      const videoPath = `/images/works/${workId}/video${videoNumber}.mp4`;\n      \n      checkPromises.push(\n        checkVideoExists(videoPath).then((exists) => ({\n          number: i,\n          exists,\n        }))\n      );\n    }\n\n    const results = await Promise.all(checkPromises);\n    \n    // バッチ内で存在する動画ファイルを処理\n    const existingVideos = results\n      .filter((result) => result.exists)\n      .sort((a, b) => a.number - b.number);\n    \n    const batchHasVideo = existingVideos.length > 0;\n    \n    // 動画が見つかった場合は追加\n    for (const result of existingVideos) {\n      const videoNumber = result.number.toString().padStart(2, \"0\");\n      videos.push({\n        type: \"video\",\n        src: `/images/works/${workId}/video${videoNumber}.mp4`,\n        alt: `作品${workId}の動画${videoNumber}`,\n      });\n    }\n\n    // バッチ内に動画がなかった場合\n    if (!batchHasVideo) {\n      consecutiveFailures += batchSize;\n      // 連続失敗が上限に達したら検索を停止\n      if (consecutiveFailures >= maxConsecutiveFailures * batchSize) {\n        break;\n      }\n    } else {\n      // 成功したらリセット\n      consecutiveFailures = 0;\n    }\n  }\n\n  return videos;\n}\n\n/**\n * public/images/works内の連番フォルダを検出する関数\n * サムネイル画像の存在を確認して、有効なフォルダを判定\n * 最適化: バッチ処理で並列数を制限\n */\nexport async function detectWorksFolders(\n  maxId: number = 20\n): Promise<number[]> {\n  const detectedFolders: number[] = [];\n  const batchSize = 5; // 一度に5個ずつチェック\n\n  // バッチ処理で並列数を制限\n  for (let batchStart = 1; batchStart <= maxId; batchStart += batchSize) {\n    const batchEnd = Math.min(batchStart + batchSize - 1, maxId);\n    const checkPromises: Promise<boolean>[] = [];\n\n    // バッチ内のIDをチェック\n    for (let id = batchStart; id <= batchEnd; id++) {\n      // thumbnail.webpとthumbnail.pngの両方をチェック\n      const thumbnailWebpPath = `/images/works/${id}/thumbnail.webp`;\n      const thumbnailPngPath = `/images/works/${id}/thumbnail.png`;\n      \n      checkPromises.push(\n        Promise.all([\n          checkImageExists(thumbnailWebpPath),\n          checkImageExists(thumbnailPngPath)\n        ]).then(([existsWebp, existsPng]) => {\n          if (existsWebp || existsPng) {\n            detectedFolders.push(id);\n          }\n          return existsWebp || existsPng;\n        })\n      );\n    }\n\n    // バッチごとに並列で画像の存在を確認\n    await Promise.all(checkPromises);\n  }\n\n  // 数値順にソート\n  return detectedFolders.sort((a, b) => a - b);\n}\n\n/**\n * デフォルトのworksデータを生成する関数\n */\nexport function generateDefaultWorkData(id: number): Works {\n  const currentDate = new Date();\n  const year = currentDate.getFullYear();\n  const month = String(currentDate.getMonth() + 1).padStart(2, \"0\");\n  const dateString = `${year}.${month}`;\n\n  return {\n    id,\n    title: `作品 ${id}`,\n    date: dateString,\n    role: \"開発・デザイン\",\n    client: \"クライアント名\",\n    industry: \"その他\",\n    technologies: [\"HTML\", \"CSS\", \"JavaScript\"] as Technology[],\n    category: [\"サービスサイト\"] as WorkCategory[],\n    details: {\n      overview: [\"作品の概要をここに記入してください。\"],\n      challenge: [\"課題をここに記入してください。\"],\n      solution: [\"解決策をここに記入してください。\"],\n      result: [\"成果をここに記入してください。\"],\n      features: [\"主な機能をここに記入してください。\"],\n      link: \"\",\n    },\n    mediaData: {\n      images: [],\n      videos: [],\n    },\n    isVisible: true,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * 既存のworksデータと自動生成データをマージする関数\n * 既存データを優先し、存在しないIDのみ自動生成データを追加\n */\nexport function mergeWorksData(\n  existingWorks: Works[],\n  autoGeneratedWorks: Works[]\n): Works[] {\n  const existingIds = new Set(existingWorks.map((work) => work.id));\n  const newWorks = autoGeneratedWorks.filter(\n    (work) => !existingIds.has(work.id)\n  );\n\n  // 既存データと新規データをマージ（既存データを優先）\n  return [...existingWorks, ...newWorks].sort((a, b) => a.id - b.id);\n}\n\n/**\n * 既存のworksデータの動画ファイルを自動検出・更新する関数\n * 最適化: 既に動画データがある場合はスキップ\n */\nexport async function updateVideoFilesInWorks(\n  works: Works[]\n): Promise<Works[]> {\n  console.log(\"🎬 動画ファイルを自動検出中...\");\n\n  const updatedWorks = await Promise.all(\n    works.map(async (work) => {\n      // 既に動画データが存在し、かつ空でない場合はスキップ（パフォーマンス向上）\n      if (work.mediaData.videos && work.mediaData.videos.length > 0) {\n        console.log(`⏭️ 作品${work.id}: 既存の動画データがあるためスキップ`);\n        return work;\n      }\n\n      const detectedVideos = await detectVideoFiles(work.id);\n      \n      if (detectedVideos.length > 0) {\n        console.log(\n          `✅ 作品${work.id}: ${detectedVideos.length}個の動画ファイルを検出しました`\n        );\n      } else {\n        console.log(`ℹ️ 作品${work.id}: 動画ファイルが見つかりませんでした`);\n      }\n      \n      // 動画が検出されなかった場合も空の配列を設定して、既存の動画データをクリア\n      return {\n        ...work,\n        mediaData: {\n          ...work.mediaData,\n          videos: detectedVideos,\n        },\n      };\n    })\n  );\n\n  return updatedWorks;\n}\n\n/**\n * フォルダから自動的にworksデータを生成する関数\n */\nexport async function autoGenerateWorksData(\n  existingWorks: Works[]\n): Promise<Works[]> {\n  console.log(\"🔍 worksフォルダを自動検出中...\");\n\n  // フォルダを検出\n  const detectedFolders = await detectWorksFolders(20);\n  console.log(\n    `✅ ${detectedFolders.length}個のworksフォルダを検出しました:`,\n    detectedFolders\n  );\n\n  if (detectedFolders.length === 0) {\n    console.log(\"⚠️ worksフォルダが見つかりませんでした\");\n    // フォルダが見つからなくても、既存データの動画ファイルを更新\n    return await updateVideoFilesInWorks(existingWorks);\n  }\n\n  // 既存のIDを取得\n  const existingIds = new Set(existingWorks.map((work) => work.id));\n\n  // 検出されたフォルダから、既存データにないIDのworksデータを生成\n  const newWorks: Works[] = [];\n  for (const id of detectedFolders) {\n    if (!existingIds.has(id)) {\n      const defaultWork = generateDefaultWorkData(id);\n      newWorks.push(defaultWork);\n      console.log(`📝 新規worksデータを生成しました: ID ${id}`);\n    }\n  }\n\n  // 既存データとマージ\n  let mergedWorks = mergeWorksData(existingWorks, newWorks);\n\n  // すべてのworksデータの動画ファイルを自動検出・更新\n  mergedWorks = await updateVideoFilesInWorks(mergedWorks);\n\n  console.log(\n    `✅ worksデータをマージしました: 合計 ${mergedWorks.length}件`\n  );\n\n  return mergedWorks;\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}